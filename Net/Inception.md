- 这里推荐一下这个[GitHub](https://github.com/SnailTyan/deep-learning-papers-translation)，博主将常见的论文都做了翻译，大家可以参考中文来加深理解。

## 1.Inception v1

### 1.1 Introduction

Inception V1是来源于[《Going deeper with convolutions》](https://arxiv.org/abs/1409.4842)，论文主要介绍了，如何在有限的计算资源内，进一步提升网络的性能。

提升网络的性能的方法有很多，例如硬件的升级，更大的数据集等。但一般而言，提升网络性能最直接的方法是增加网络的深度和宽度。其中，网络的深度只的是网络的层数，宽度指的是每层的通道数。但是，这种方法会带来两个不足：

　　a) 容易发生过拟合。当深度和宽度不断增加的时候，需要学习到的参数也不断增加，巨大的参数容易发生过拟合。

　　b) 均匀地增加网络的大小，会导致计算量的加大。

因此，解决上述不足的方法是引入稀疏特性和将全连接层转换成稀疏连接。这个思路的缘由来自于两方面：1）生物的神经系统连接是稀疏的；2）有文献指出：如果数据集的概率分布能够被大型且非常稀疏的DNN网络所描述的话，那么通过分析前面层的激活值的相关统计特性和将输出高度相关的神经元进行聚类，便可逐层构建出最优的网络拓扑结构。说明臃肿的网络可以被不失性能地简化。

但是，现在的计算框架对非均匀的稀疏数据进行计算是非常低效的，主要是因为查找和缓存的开销。因此，作者提出了一个想法，既能保持滤波器级别的稀疏特性，又能充分密集矩阵的高计算性能。有大量文献指出，将稀疏矩阵聚类成相对密集的子矩阵，能提高计算性能。根据此想法，提出了Inception结构。

### 1.2 Inception结构

inception结构的主要思路是：如何使用一个密集成分来近似或者代替最优的局部稀疏结构。inception V1的结构如下面两个图所示。

 ![img](https://img2018.cnblogs.com/blog/1456303/201905/1456303-20190504162301047-898768446.png)

![img](https://img2018.cnblogs.com/blog/1456303/201905/1456303-20190504162327115-2119269106.png)

对于上图中的（a）做出几点解释：

　　a）采用不同大小的卷积核意味着不同大小的感受野，最后拼接意味着不同尺度特征的融合； 

　　b）之所以卷积核大小采用1、3和5，主要是为了方便对齐；

　　c）文章说很多地方都表明pooling挺有效，所以Inception里面也嵌入了；

　　d）网络越到后面，特征越抽象，而且每个特征所涉及的感受野也更大了，因此随着层数的增加，3x3和5x5卷积的比例也要增加。

但是，使用5x5的卷积核仍然会带来巨大的计算量。 为此，文章借鉴NIN，采用1x1卷积核来进行降维，如图中（b）所示。
例如：上一层的输出为100x100x128，经过具有256个输出的5x5卷积层之后(stride=1，pad=2)，输出数据的大小为100x100x256。其中，卷积层的参数为5x5x128x256。假如上一层输出先经过具有32个输出的1x1卷积层，再经过具有256个输出的5x5卷积层，那么最终的输出数据的大小仍为100x100x256，但卷积参数量已经减少为1x1x128x32 + 5x5x32x256，大约减少了4倍。

在inception结构中，大量采用了1x1的矩阵，主要是两点作用：1）对数据进行降维；2）引入更多的非线性，提高泛化能力，因为卷积后要经过ReLU激活函数。

### 1.3 GoogLeNet

GoogLeNet是由inception模块进行组成的，结构太大了，就不放出来了，这里做出几点说明：

　　a）GoogLeNet采用了模块化的结构，方便增添和修改；

　　b）网络最后采用了average pooling来代替全连接层，想法来自NIN,事实证明可以将TOP1 accuracy提高0.6%。但是，实际在最后还是加了一个全连接层，主要是为了方便以后大家finetune;

　　c）虽然移除了全连接，但是网络中依然使用了Dropout；

　　d）为了避免梯度消失，网络额外增加了2个辅助的softmax用于向前传导梯度。文章中说这两个辅助的分类器的loss应该加一个衰减系数，但看源码中的model也没有加任何衰减。此外，实际测试的时候，这两个额外的softmax会被去掉。

### 参考文献：

　　[1] https://blog.csdn.net/qq_38906523/article/details/80061075

　　[2] Inception  v1的TensorFlow源码：https://github.com/tensorflow/tensorflow/blob/master/tensorflow/contrib/slim/python/slim/nets/inception_v1.py

 

## 2.Inception v2

### 2.1 introduction

Inception v2来自于论文[《Batch Normalization: Accelerating Deep Network Training by Reducing Internal Covariate Shift》](https://arxiv.org/abs/1502.03167)。

训练DNN网络的一个难点是，在训练时每层输入数据的分布会发生改变，所以需要较低的学习率和精心设置初始化参数。只要网络的前面几层发生微小的改变，那么后面几层就会被累积放大下去。一旦网络某一层的输入数据的分布发生改变，那么这一层网络就需要去适应学习这个新的数据分布，所以如果训练过程中，训练数据的分布一直在发生变化，那么将会影响网络的训练速度。作者把网络中间层在训练过程中，数据分布的改变称之为：“Internal  Covariate Shift”。因此，作者提出对数据做归一化的想法。

对数据进行了BN算法后，具有以下的优点：

　　a）可以设置较大的初始学习率，并且减少对参数初始化的依赖，提高了训练速度；

　　b）这是个正则化模型，因此可以去除dropout和降低L2正则约束参数；

　　c）不需要局部响应归一化层；

　　d）能防止网络陷入饱和，即消除梯度弥散。

### 2.2 BN算法

BN算法通过下面公式，对某一层进行归一化处理，也叫近似白化预处理：

 

*𝑥*(*𝑘*)ˆ=*𝑥*(*𝑘*)−*𝐸*[*𝑥*(*𝑘*)]*𝑉**𝑎**𝑟*(*𝑥*(*𝑘*))‾‾‾‾‾‾‾‾‾√





其中，由于我们是采用批量梯度下降法的，所以*𝐸*[*𝑥*(*𝑘*)]

是指在一批数据中，各神经元的平均值；*𝑉**𝑎**𝑟*(*𝑥*(*𝑘*))

是指在一批训练数据时各神经元输入值的标准差。

如果是仅仅使用上面的归一化公式，对网络某一层A的输出数据做归一化，然后送入网络下一层B，这样是会影响到本层网络A所学习到的特征的。打个比方，比如我网络中间某一层学习到特征数据本身就分布在S型激活函数的两侧，你强制把它给我归一化处理、标准差也限制在了1，把数据变换成分布于s函数的中间部分，这样就相当于我这一层网络所学习到的特征分布被搞坏了。

于是，提出了“变换重构”，引入了可学习参数*𝛾*

和*𝛽*

：



*𝑦*(*𝑘*)=*𝛾*(*𝑘*)*𝑥*(*𝑘*)ˆ+*𝛽*(*𝑘*)





每一个神经元*𝑥*(*𝑘*)

都会有这样的一对参数*𝛾*和*𝛽*。当*𝛾*(*𝑘*)=*𝑉**𝑎**𝑟*(*𝑥*(*𝑘*))‾‾‾‾‾‾‾‾‾√和*𝛽*(*𝑘*)=*𝐸*[*𝑥*(*𝑘*)]

时，是可以恢复出原始的某一层所学到的特征的。

> 通过上面的学习，我们知道BN层是对于每个神经元做归一化处理，甚至只需要对某一个神经元进行归一化，而不是对一整层网络的神经元进行归一化。既然BN是对单个神经元的运算，那么在CNN中卷积层上要怎么搞？假如某一层卷积层有6个特征图，每个特征图的大小是100*100，这样就相当于这一层网络有6*100*100个神经元，如果采用BN，就会有6*100*100个参数γ、β，这样岂不是太恐怖了。因此卷积层上的BN使用，其实也是使用了类似**权值共享**的策略，**把一整张特征图当做一个神经元进行处理**。
>
> 卷积神经网络经过卷积后得到的是一系列的特征图，如果min-batch  sizes为m，那么网络某一层输入数据可以表示为四维矩阵(m,f,p,q)，m为min-batch  sizes，f为特征图个数，p、q分别为特征图的宽高。在cnn中我们可以把每个特征图看成是一个特征处理（一个神经元），因此在使用Batch  Normalization，mini-batch size  的大小就是：m*p*q，于是对于每个特征图都只有一对可学习参数：γ、β。说白了吧，这就是相当于求取所有样本所对应的一个特征图的所有神经元的平均值、方差，然后对这个特征图神经元做归一化。

### 参考文献：

　　[1] https://blog.csdn.net/qq_26898461/article/details/51221166

 

## 3.Inception v3

Inception v3是来源于论文《[Rethinking the Inception Architecture for Computer Vision](https://arxiv.org/abs/1512.00567)》，主要是引入了因子分解的思想。

### 3.1 General Design Principles

复杂的inception结构，使得我们很难对网络进行修改。如果盲目的扩大网络，反而会增大计算量。所以，本论文首先给出了几条通用的原则和优化的思想：

- 避免特征表示瓶颈，尤其是在网络的前面。要避免严重压缩导致的瓶颈。特征表示尺寸应该温和地减少，从输入端到输出端。特征表示的维度只是一个粗浅的信息量表示，它丢掉了一些重要的因素如相关性结构。
- 高维信息更适合在网络的局部处理。在卷积网络中逐步增加非线性激活响应可以解耦合更多的特征，那么网络就会训练的更快。
- 空间聚合可以通过低维嵌入，不会导致网络表示能力的降低。例如在进行大尺寸的卷积（如3*3）之前，我们可以在空间聚合前先对输入信息进行降维处理，如果这些信号是容易压缩的，那么降维甚至可以加快学习速度。
- 平衡好网络的深度和宽度。通过平衡网络每层滤波器的个数和网络的层数可以是网络达到最佳性能。增加网络的宽度和深度都会提升网络的性能，但是两者并行增加获得的性能提升是最大的。所以计算资源应该被合理的分配到网络的宽度和深度。 

### 3.2 Factorizing Convolutions with Large Filter Size

大尺度滤波器的卷积（如5*5，7*7）的引入，会产生大量的计算。例如一个5*5的卷积比一个3*3卷积滤波器多25/9=2.78倍计算量。当然5*5滤波器可以学习到更多的信息。那么我们能不能使用一个多层感知器来代替这个5*5卷积滤波器。

因此，提出了使用两个级联的3*3的滤波器来代替一个5*5的滤波器，这样节省了(5*5)/(2*3*3)=1.39被计算量，如下图的左图所示。因此，inception v1中的模块可以被替换成下图的右图所示。

![img](https://img2018.cnblogs.com/blog/1456303/201905/1456303-20190526190427129-1350878604.png)![img](https://img2018.cnblogs.com/blog/1456303/201905/1456303-20190526190452439-1001983719.png)

受到上面的启发，又进一步对卷进进一步分解，将3*3的卷积核分解为3*1+1*3，如下图所示。这样，又能进一步降低计算量。因此，一个n*n的卷积可以被1*n和n*1的卷积所代替。但实际上，在网络模型的前期使用这样的卷积分解，并不能达到一个很好的效果。通过在网络中期使用，在特征图的尺寸为12-20左右使用最佳。

![img](https://img2018.cnblogs.com/blog/1456303/201905/1456303-20190526182203866-1743789611.png)

### 3.3 其他思想

- 利用辅助决策分支，来加快收敛速度。在inception v1中，引入了辅助决策分支。但是本文证明了，底层的辅助决策分支并不能起到很好的作用。如果辅助决策分支进行归一化或者dropout，效果会更好。
- 利用平行的池化与卷积，来进行特征图尺寸缩小，不仅能较少计算量，又能防止特征瓶颈，如下图所示。

![img](https://img2018.cnblogs.com/blog/1456303/201905/1456303-20190526185740859-157172222.png)

- 提出了Label Smoothing

### 参考文献：

　　[1] https://www.cnblogs.com/vincentqliu/p/7467298.html

 

## 4. Inception v4

 Inception V4来自于论文《[Inception-v4, Inception-ResNet and the Impact of Residual Connections on Learning](https://arxiv.org/abs/1602.07261v1)》，主要提出了新的Inception结构，并且结合ResNet网络提出了Inception-ResNet-v1和Inception-ResNet-v2。

### 4.1 introduction

文章中提出了一个疑问：当网络更深更宽时，inception网络能否一样高效。基于这个想法，将inception和resnet两者进行融合，进一步改善网络。由于TensorFlow的出现，能大大简化训练，不需要将模型进行分割。因此，google采取了更加大胆的设计方法，提出了inception v4，其具有更加统一的inception结构。

### 4.2 inception v4，Inception-ResNet结构

![img](https://img2018.cnblogs.com/blog/1456303/201906/1456303-20190602152722433-1671060023.png)

 

 ![img](https://img2018.cnblogs.com/blog/1456303/201906/1456303-20190602153609295-1609513138.png)

 

![img](https://img2018.cnblogs.com/blog/1456303/201906/1456303-20190602154317266-259663275.png)

可以看出，这3种结构还是相当复杂的，即使比之前的inception模块统一了很多。

 

### 总结

inception是通过增加网络的宽度来提高网络性能，在每个inception模块中，使用了不同大小的卷积核，可以理解成不同的感受野，然后将其concentrate起来，丰富了每层的信息。之后，使用了BN算法（BN使用在conv之后，relu之前），来加速网络的收敛速度。在V3版本中，还使用了卷积因子分解的思想，将大卷积核分解成小卷积，节省了参数，降低了模型大小。在V4版本中，使用了更加统一的inception模块，并结合了resnet的残差思想，能将网络做得更深。