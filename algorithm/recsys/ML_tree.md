### 决策树

决策树是一个有监督的分类模型，其本质是选择一个能带来**最大信息增益**的特征值进行树的



**1）、ID3：以信息增益为准则来选择最优划分属性**

信息增益的计算要基于信息熵（度量样本集合纯度的指标）

![img](https://xiaoguciu.oss-cn-beijing.aliyuncs.com/imgv2-e0ce667594401d2f8daf3ee6a7da9151_720w.jpg)信息熵越小，数据集X的纯度越大

因此，假设于数据集D上建立决策树，数据有K个类别：

<img src="https://xiaoguciu.oss-cn-beijing.aliyuncs.com/imgv2-f6d10699fdbe216617836c7e8732ba58_720w.jpg" alt="img" style="zoom:50%;" />

公式（1）中：

![img](https://xiaoguciu.oss-cn-beijing.aliyuncs.com/imgv2-181bbc695d6de40eff56d86518d84f29_720w.jpg)表示第k类样本的数据占数据集D样本总数的比例

公式（2）表示的是以特征A作为分割的属性，得到的信息熵：

Di表示的是以属性A为划分，分成n个分支，第i个分支的节点集合

因此，该公式求的是以属性A为划分，n个分支的信息熵总和

公式（3）为分割后与分割前的信息熵的差值，也就是信息增益，越大越好

但是这种分割算法存在一定的**缺陷**：

​     假设每个记录有一个属性“ID”，若按照ID来进行分割的话，由于ID是唯一的，因此在这一个属性上，能够取得的特征值等于样本的数目，也就是说ID的特征值很多。那么无论以哪个ID为划分，叶子结点的值只会有一个，纯度很大，得到的信息增益会很大，但这样划分出来的决策树是没意义的。由此可见，**ID3决策树偏向于取值较多的属性进行分割，存在一定的偏好。**为减小这一影响，有学者提出C4.5的分类算法。



**2）、C4.5：基于信息增益率准则选择最优分割属性的算法**

​      信息增益比率通过引入一个被称作分裂信息(Split information)的项来惩罚取值较多的属性。

![img](https://xiaoguciu.oss-cn-beijing.aliyuncs.com/imgv2-c35719627c479737cb680c3f4d8cdf6d_720w.jpg)

​      上式，分子计算与ID3一样，分母是由属性A的特征值个数决定的，个数越多，IV值越大，信息增益率越小，这样就可以避免模型偏好特征值多的属性，但是聪明的人一看就会发现，如果简单的按照这个规则来分割，模型又会偏向特征数少的特征。因此C4.5决策树先从候选划分属性中找出**信息增益高于平均水平**的属性，在从中选择**增益率最高**的。

​      对于连续值属性来说，可取值数目不再有限，因此可以采用离散化技术（如二分法）进行处理。将属性值从小到大排序，然后选择中间值作为分割点，数值比它小的点被划分到左子树，数值不小于它的点被分到又子树，计算分割的信息增益率，选择信息增益率最大的属性值进行分割。

**3）CART：以基尼系数为准则选择最优划分属性，可以应用于分类和回归**

​      CART是一棵二叉树，采用二元切分法，每次把数据切成两份，分别进入左子树、右子树。而且每个非叶子节点都有两个孩子，所以CART的叶子节点比非叶子多1。相比ID3和C4.5，CART应用要多一些，既可以用于分类也可以用于回归。CART分类时，使用基尼指数（Gini）来选择最好的数据分割的特征，gini描述的是纯度，与信息熵的含义相似。CART中每一次迭代都会降低GINI系数。

<img src="https://xiaoguciu.oss-cn-beijing.aliyuncs.com/imgv2-79214da261d75829046953ab9cb8b03a_720w.jpg" alt="img" style="zoom:50%;" />Di表示以A是属性值划分成n个分支里的数目

Gini(D)反映了数据集D的纯度，值越小，纯度越高。我们在候选集合中选择使得划分后基尼指数最小的属性作为最优化分属性。

**分类树和回归树**

​      提到决策树算法，很多想到的就是上面提到的ID3、C4.5、CART分类决策树。其实决策树分为分类树和回归树，前者用于分类，如晴天/阴天/雨天、用户性别、邮件是否是垃圾邮件，后者用于预测实数值，如明天的温度、用户的年龄等。

​       作为对比，先说分类树，我们知道ID3、C4.5分类树在每次分枝时，是穷举每一个特征属性的每一个阈值，找到使得按照feature<=阈值，和feature>阈值分成的两个分枝的信息增益最大的feature和阈值。按照该标准分枝得到两个新节点，用同样方法继续分枝直到所有人都被分入性别唯一的叶子节点，或达到预设的终止条件，若最终叶子节点中的性别不唯一，则以多数人的性别作为该叶子节点的性别。

​       回归树总体流程也是类似，不过在每个节点（不一定是叶子节点）都会得一个预测值，以年龄为例，该预测值等于属于这个节点的所有人年龄的平均值。分枝时穷举每一个feature的每个阈值找最好的分割点，但衡量最好的标准不再是最大熵，而是最小化均方差--即（每个人的年龄-预测年龄）^2 的总和 / N，或者说是每个人的预测误差平方和 除以  N。这很好理解，被预测出错的人数越多，错的越离谱，均方差就越大，通过最小化均方差能够找到最靠谱的分枝依据。分枝直到每个叶子节点上人的年龄都唯一（这太难了）或者达到预设的终止条件（如叶子个数上限），若最终叶子节点上人的年龄不唯一，则以该节点上所有人的平均年龄做为该叶子节点的预测年龄。  

**二、随机森林**

在讲随机森林之前，我们需要补充一点**组合分类器**的概念，将多个分类器的结果进行多票表决或者是取平均值，以此作为最终的结果。

1、构建组合分类器的好处：

（1）、提升模型精度：整合各个模型的分类结果，得到更合理的决策边界，减少整体错误，实现更好的分类效果；

![img](https://xiaoguciu.oss-cn-beijing.aliyuncs.com/imgv2-8fc5ff86df06a3c4d3f7d4b055642224_720w.jpg)

（2）、处理过大或过小的数据集：数据集较大时，可以将数据集划分成多个子集，对子集构建分类器；数据集较小时，可通过多种抽样方式（bootstrap）从原始数据集抽样产生多组不同的数据集，构建分类器。

（3）、若决策边界过于复杂，则线性模型不能很好地描述真实情况。因此先对于特定区域的数据集，训练多个线性分类器，再将它们集成。

![img](https://xiaoguciu.oss-cn-beijing.aliyuncs.com/imgv2-fdd9a957b915ec7711c68af1b365b30f_720w.jpg)

（4）、比较适合处理多源异构数据（存储方式不同（关系型、非关系型），类别不同（时序型、离散型、连续型、网络结构数据））

![img](https://xiaoguciu.oss-cn-beijing.aliyuncs.com/imgv2-2743e0131bdb39de81f01649bc0f3b4e_720w.jpg)

​      随机森林是一个典型的多个决策树的组合分类器。主要包括两个方面：数据的随机性选取，以及待选特征的随机选取。

（1）、数据的随机选取：
       第一，从原始的数据集中采取有放回的抽样（bootstrap），构造子数据集，子数据集的数据量是和原始数据集相同的。不同子数据集的元素可以重复，同一个子数据集中的元素也可以重复。
        第二，利用子数据集来构建子决策树，将这个数据放到每个子决策树中，每个子决策树输出一个结果。最后，如果有了新的数据需要通过随机森林得到分类结果，就可以通过对子决策树的判断结果的投票，得到随机森林的输出结果了。如下图，假设随机森林中有3棵子决策树，2棵子树的分类结果是A类，1棵子树的分类结果是B类，那么随机森林的分类结果就是A类。



![img](https://xiaoguciu.oss-cn-beijing.aliyuncs.com/imgv2-a1c3ce43528dbc274be8952c06d2b9b4_720w.jpg)

（2）、待选特征的随机选取：
      与数据集的随机选取类似，随机森林中的子树的每一个分裂过程并未用到所有的待选特征，而是从所有的待选特征中随机选取一定的特征，之后再在随机选取的特征中选取最优的特征。这样能够使得随机森林中的决策树都能够彼此不同，提升系统的多样性，从而提升分类性能。

![img](https://xiaoguciu.oss-cn-beijing.aliyuncs.com/imgv2-569009cc3ccd3e9922b77c1e4cbf4ca0_720w.jpg)组合树示例图



三、GBDT和xgboost

（1）、在讲GBDT和xgboost之前，需要补充两个基本知识：bagging和boosting

Bagging的思想比较简单，即每一次从原始数据中根据**均匀概率分布有放回的抽取和原始数据大小相同的样本集合**，样本点可能出现重复，然后对每一次产生的训练集构造一个分类器，再对分类器进行组合。

boosting的每一次抽样的**样本分布都是不一样的**。每一次迭代，都根据上一次迭代的结果，**增加被错误分类的样本的权重**，使得模型能在之后的迭代中更加注意到难以分类的样本，这是一个**不断学习的过程，也是一个不断提升**的过程，这也就是boosting思想的本质所在。迭代之后，将每次迭代的基分类器进行集成。那么如何进行样本权重的调整和分类器的集成是我们需要考虑的关键问题。

![img](https://xiaoguciu.oss-cn-beijing.aliyuncs.com/imgv2-aca3644ddd56abe1e47c0f45601587c3_720w.jpg)boosting算法结构图

拿著名的**Adaboost算法**举例：

![img](https://xiaoguciu.oss-cn-beijing.aliyuncs.com/imgv2-42d79b3f2d50c86679f7c9bbc088d5f7_720w.jpg)我们有一个数据集，样本大小为N，每一个样本对应一个原始标签起初，我们初始化样本的权重为1/N



![img](https://xiaoguciu.oss-cn-beijing.aliyuncs.com/imgv2-3f8463843d3f88642a288666ecb94ff1_720w.jpg)em计算的是当前数据下，模型的分类误差率，模型的系数值是基于分类误差率的

![img](https://xiaoguciu.oss-cn-beijing.aliyuncs.com/imgv2-8d2590f60815d6389572d4f09ed9a658_720w.jpg)根据模型的分类结果，更新原始数据中数据的分布，增加被错分的数据被抽中的概率，以便下一次迭代的时候能被模型重新训练

![img](https://xiaoguciu.oss-cn-beijing.aliyuncs.com/imgv2-7000a239700933215671f4f66066ddd4_720w.jpg)最终的分类器是各个基分类器的组合

（2）、GBDT

​     GBDT是以决策树（CART）为基学习器的GB算法，是**迭代树**，而不是分类树。Boost是"提升"的意思，一般Boosting算法都是一个迭代的过程，每一次新的训练都是为了改进上一次的结果。有了前面Adaboost的铺垫，大家应该能很容易理解大体思想。

![img](https://xiaoguciu.oss-cn-beijing.aliyuncs.com/imgv2-4713a5b63da71ef5afba3fcd3a65299d_720w.jpg)


       GBDT的核心就在于：**每一棵树学的是之前所有树结论和的残差**，这个残差就是一个加预测值后能得真实值的累加量。比如A的真实年龄是18岁，但第一棵树的预测年龄是12岁，差了6岁，即残差为6岁。那么在第二棵树里我们把A的年龄设为6岁去学习，如果第二棵树真的能把A分到6岁的叶子节点，那累加两棵树的结论就是A的真实年龄；如果第二棵树的结论是5岁，则A仍然存在1岁的残差，第三棵树里A的年龄就变成1岁，继续学习。

![img](https://xiaoguciu.oss-cn-beijing.aliyuncs.com/imgv2-a384924b89b1bdd581cef7d75b56e226_720w.jpg)

（3）、xgboost

Xgboost相比于GBDT来说，更加有效应用了**数值优化，最重要是对损失函数**（预测值和真实值的误差）**变得更复杂**。目标函数依然是所有树的预测值相加等于预测值。

损失函数如下，引入了一阶导数，二阶导数。：

![img](https://xiaoguciu.oss-cn-beijing.aliyuncs.com/imgv2-1c0706e463f78b6036b3923048ac9149_720w.jpg)好的模型需要具备两个基本要素：一是要有好的精度（即好的拟合程度），二是模型要尽可能的简单（复杂的模型容易出现过拟合，并且更加不稳定）因此，我们构建的目标函数右边第一项是模型的误差项，第二项是正则化项（也就是模型复杂度的惩罚项）

常用的误差项有平方误差和逻辑斯蒂误差，常见的惩罚项有l1，l2正则，l1正则是将模型各个元素进行求和，l2正则是对元素求平方。

![img](https://xiaoguciu.oss-cn-beijing.aliyuncs.com/imgv2-a9b82954ae62e9e6da256c69ba22d38b_720w.jpg)每一次迭代，都在现有树的基础上，增加一棵树去拟合前面树的预测结果与真实值之间的残差

![img](https://xiaoguciu.oss-cn-beijing.aliyuncs.com/imgv2-f0cd240fcc70e7615dae7c2a29856bfc_720w.jpg)目标函数如上图，最后一行画圈部分实际上就是预测值和真实值之间的残差

先对训练误差进行展开：

![img](https://xiaoguciu.oss-cn-beijing.aliyuncs.com/imgv2-9f9f93d4a9d618d14201836d8f45a918_720w.jpg)xgboost则对代价函数进行了二阶泰勒展开，同时用到了残差平方和的一阶和二阶导数

再研究目标函数中的正则项：

![img](https://xiaoguciu.oss-cn-beijing.aliyuncs.com/imgv2-142ca609c9ff3dc2df877a00c30756ca_720w.jpg)

树的复杂度可以用树的分支数目来衡量，树的分支我们可以用叶子结点的数量来表示

那么树的复杂度式子：右边第一项是叶子结点的数量T，第二项是树的叶子结点权重w的l2正则化，正则化是为了防止叶子结点过多

此时，每一次迭代，相当于在原有模型中增加一棵树，目标函数中，我们用wq（x）表示一棵树，包括了树的结构以及叶子结点的权重，w表示权重（反映预测的概率），q表示样本所在的索引号（反映树的结构）

将最终得到的目标函数对参数w求导，带回目标函数，可知目标函数值由红色方框部分决定：

![img](https://xiaoguciu.oss-cn-beijing.aliyuncs.com/imgv2-c7ab2fcfd3196dbc0bce05d17b11d220_720w.jpg)

因此，xgboost的迭代是以下图中gain式子定义的指标选择最优分割点的：

![img](https://xiaoguciu.oss-cn-beijing.aliyuncs.com/imgv2-d0cf0063c23679e711146f861d36fc17_720w.jpg)

那么如何得到优秀的组合树呢？

​      一种办法是贪心算法，遍历一个节点内的所有特征，按照公式计算出按照每一个特征分割的信息增益，找到信息增益最大的点进行树的分割。增加的新叶子惩罚项对应了树的剪枝，当gain小于某个阈值的时候，我们可以剪掉这个分割。但是这种办法不适用于数据量大的时候，因此，我们需要运用近似算法。

​       另一种方法：XGBoost在寻找splitpoint的时候，不会枚举所有的特征值，而会对特征值进行聚合统计，按照**特征值的密度分布**，构造直方图计算特征值分布的面积，然后划分分布形成若干个bucket(桶)，每个bucket的面积相同，将**bucket边界上的特征值**作为split
point的候选，**遍历所有的候选分裂点**来找到最佳分裂点。

​       上图近似算法公式的解释：将特征k的特征值进行排序，计算特征值分布，rk（z）表示的是对于特征k而言，其特征值小于z的权重之和占总权重的比例，代表了这些特征值的重要程度，我们按照这个比例计算公式，将特征值分成若干个bucket，每个bucket的比例相同，选取这几类特征值的边界作为划分候选点，构成候选集；选择候选集的条件是要使得相邻的两个候选分裂节点差值小于某个阈值



综合以上的解说，我们可以得到xgboost相比于GBDT的创新之处：

​       传统GBDT以CART作为基分类器，xgboost还支持线性分类器，这个时候xgboost相当于带L1和L2正则化项的逻辑斯蒂回归（分类问题）或者线性回归（回归问题）。

- 传统GBDT在优化时只用到一阶导数信息，xgboost则对代价函数进行了**二阶泰勒展开，同时用到了一阶和二阶导数**。顺便提一下，xgboost工具支持自定义代价函数，只要函数可一阶和二阶求导。
- xgboost在**代价函数里加入了正则项，用于控制模型的复杂度**。正则项里包含了树的叶子节点个数、每个叶子节点上输出的score的L2模的平方和。从Bias-variance  tradeoff角度来讲，正则项降低了模型的variance，使学习出来的模型更加简单，防止过拟合，这也是xgboost优于传统GBDT的一个特性。
- **Shrinkage（缩减），相当于学习速率（xgboost中的eta）**。每次迭代，增加新的模型，在前面成上一个小于1的系数，降低优化的速度，每次走一小步逐步逼近最优模型比每次走一大步逼近更加容易避免过拟合现象；
- 列抽样（column subsampling）。xgboost借鉴了随机森林的做法，支持列抽样（即每次的输入特征不是全部特征），不仅能降低过拟合，还能减少计算，这也是xgboost异于传统gbdt的一个特性。
- 忽略缺失值：在寻找splitpoint的时候，不会对该特征为missing的样本进行遍历统计，只对该列特征值为non-missing的样本上对应的特征值进行遍历，通过这个工程技巧来减少了为稀疏离散特征寻找splitpoint的时间开销
- 指定缺失值的分隔方向：可以为缺失值或者指定的值指定分支的默认方向，为了保证完备性，会分别处理将missing该特征值的样本分配到左叶子结点和右叶子结点的两种情形，分到那个子节点带来的增益大，默认的方向就是哪个子节点，这能大大提升算法的效率。
- 并行化处理：在训练之前，预先对每个特征内部进行了排序找出候选切割点，然后保存为block结构，后面的迭代中重复地使用这个结构，大大减小计算量。在进行节点的分裂时，需要计算每个特征的增益，最终选增益最大的那个特征去做分裂，那么各个特征的增益计算就可以开多线程进行，即在不同的特征属性上采用多线程并行方式寻找最佳分割点。  

